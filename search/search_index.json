{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Still \u00b6 still is a program for validating tabular data from CSV, TSV, and Excel.","title":"Still"},{"location":"#still","text":"still is a program for validating tabular data from CSV, TSV, and Excel.","title":"Still"},{"location":"column-rules/","text":"Column Rules \u00b6 Introduction \u00b6 Column rules consist of the rule and a test expression. All test expressions return a boolean (true/false) and allow you to evaluate conditions on a column. For brevity, test expressions are implicitely passed the column being evaluated as the first argument. For example: # Column --> Status; Testing for a value containing '# NOTE' status: is(\"fail\") # Converted to: status: is(status, \"fail\") You can still be explicit when referencing the column of interest, and you can also combine test functions using different columns: # Check that a failure reason is provided for missing data. status: is(status, \"fail\") && !is_missing(reason) Operators \u00b6 still uses Knetic/govaluate to evaluate expressions. See the manual for more detail on operators. The following operators are supported. Modifiers: + - / * & | ^ ** % >> << Comparators: > >= < <= == != =~ !~ Logical ops: || && Numeric constants, as 64-bit floating point ( 12345.678 ) String constants (single quotes: 'foobar' ) Date constants ( single quotes , using any RFC3339, ISO8601, ruby date, or unix date; date parsing is automatically tried with any string constant) Boolean constants: true false Parenthesis to control order of evaluation ( ) Arrays (anything separated by , within parenthesis: (1, 2, 'foo') ) Prefixes: ! - ~ Ternary conditional: ? : Null coalescence: ?? Dates are parsed when specified as single quotes. Basic \u00b6 is \u00b6 Tests whether a value matches. color: is(\"red\") not \u00b6 Tests whether a value does not match. is_passed: not(\"fail\") Sets \u00b6 any \u00b6 Tests whether a value matches any of passed arguments. color: any(\"red\", \"blue\", \"green\") color: any(provider) You can also use an array with the IN operator, but you must specify the column name: color: color IN (\"red\", \"blue\", \"green\") unique \u00b6 Tests whether a column is unique. items: unique() # You can also test that a set of columns are unique. color: unique(size, weight) # remember that color is implicit Note unique does not work well on large datasets. It stores a hash digest of the arguments to test for uniqueness. identical \u00b6 Tests whether all values of a column are identical. dataset_id: identical() is_subset_list \u00b6 is_subset_list(group_set, column_delimiter) group_set - A comma-delimited set of values. column_delimiter - The delimiter for the specified column you are testing. Tests whether a delimited list (nested data) is a subset of the specified delimited list. For example: letters: is_subset_list(\"A,B,C\", \",\") # If letters='A,B' --> TRUE letters: is_subset_list(\"A,C\", \",\") # If letters='A'B' --> FALSE Numbers \u00b6 range \u00b6 range(lower, upper) Tests whether a value falls between lower and upper inclusive. rating: range(0,10) is_positive \u00b6 Tests whether a value is positive. is_negative \u00b6 Tests whether a value is negative. Strings \u00b6 contains \u00b6 contains(substring) Tests for the presence of a substring in a value. regex \u00b6 regex(expression) Tests whether a value matches a regular expression. You can also use =~ or !~ regex comparators. (colname =~ \"L[0-9]+\") uppercase \u00b6 Tests whether a value is all uppercase. lowercase \u00b6 Tests whether a value is all lowercase. length \u00b6 length(min_len, max_len) Tests for string length in a given column. # Test for exact length match column: length(10) # Test for minimum length column: length(10, \"*\") # Test for range of lengths column: length(10, 20) is_url \u00b6 Tests whether a string is a valid URL Types \u00b6 is_numeric \u00b6 Checks if the value numeric. is_int \u00b6 Checks if the value an integer. is_bool \u00b6 Tests that column contains true , TRUE , false , or FALSE is_string \u00b6 Checks if the value is a string. This is done by checking that it does not look like an integer, bool, or numeric. Dates \u00b6 is_date \u00b6 Checks whether a value is date-like using strict criteria. is_date will fail on ambiguous date strings. For example, 02/03/2020 is interpretted differently in Europe vs. the US but 2020-02-03 is not. is_date_relaxed \u00b6 Checks whether a value is date-like with potential ambiguity. 02/03/2020 would pass. is_date_format \u00b6 Check whether a column matches a specified date format. Formats can be specified as any date like this: September 17, 2012, 10:10:09 oct. 7, 70 8/8/1965 12:00:00 AM 2006-01-02T15:04:05+0000 2014-04-26 date_of_birth: is_date_format(\"June 10, 1987\") See araddon/dateparse for more examples. Important! You need to escape date values containing dashes using brackets ( [] ) or a double backslash ( \\\\ ). For example 2020-02-10 is escaped like this: collection_date: is_date_format(\"[2020-02-10]\") collection_date: is_date_format(\"2020\\\\-02\\\\-10\") Files \u00b6 file_exists \u00b6 Checks whether a file exists file_min_size \u00b6 Checks whether a file is a minimum size photo: file_min_size(\"1MB\") fsize is a size string such as 100 mb , 1G , or 500 . mimetype \u00b6 Validates the mimetype for a given file. See gabriel-vasile/mimetype for available mimetypes. photo: mimetype(\"image/jpeg\") Missing Data \u00b6 is_na \u00b6 Checks whether a value is NA . Use !is_na() to restrict the presence of EMPTY values. name: !is_na() # tests that no NA values exist is_empty \u00b6 Checks whether a value is EMPTY . Use !is_empty() to restrict the presence of EMPTY values. name: !is_empty() # tests that no EMPTY values exist is_missing \u00b6 Returns true if is_na() or is_empty() is true. name: !is_empty() # tests that no NA or EMPTY values exist Providers \u00b6 Providers allow you to specify arguments in test expressions from an external data source. For example, if you want to restrict Schema YAML \u00b6 You can append YAML data to the end of a .still datafile. See Schmema YAML Data for more details. YAML File \u00b6","title":"Column Rules"},{"location":"column-rules/#column_rules","text":"","title":"Column Rules"},{"location":"column-rules/#introduction","text":"Column rules consist of the rule and a test expression. All test expressions return a boolean (true/false) and allow you to evaluate conditions on a column. For brevity, test expressions are implicitely passed the column being evaluated as the first argument. For example: # Column --> Status; Testing for a value containing '# NOTE' status: is(\"fail\") # Converted to: status: is(status, \"fail\") You can still be explicit when referencing the column of interest, and you can also combine test functions using different columns: # Check that a failure reason is provided for missing data. status: is(status, \"fail\") && !is_missing(reason)","title":"Introduction"},{"location":"column-rules/#operators","text":"still uses Knetic/govaluate to evaluate expressions. See the manual for more detail on operators. The following operators are supported. Modifiers: + - / * & | ^ ** % >> << Comparators: > >= < <= == != =~ !~ Logical ops: || && Numeric constants, as 64-bit floating point ( 12345.678 ) String constants (single quotes: 'foobar' ) Date constants ( single quotes , using any RFC3339, ISO8601, ruby date, or unix date; date parsing is automatically tried with any string constant) Boolean constants: true false Parenthesis to control order of evaluation ( ) Arrays (anything separated by , within parenthesis: (1, 2, 'foo') ) Prefixes: ! - ~ Ternary conditional: ? : Null coalescence: ?? Dates are parsed when specified as single quotes.","title":"Operators"},{"location":"column-rules/#basic","text":"","title":"Basic"},{"location":"column-rules/#is","text":"Tests whether a value matches. color: is(\"red\")","title":"is"},{"location":"column-rules/#not","text":"Tests whether a value does not match. is_passed: not(\"fail\")","title":"not"},{"location":"column-rules/#sets","text":"","title":"Sets"},{"location":"column-rules/#any","text":"Tests whether a value matches any of passed arguments. color: any(\"red\", \"blue\", \"green\") color: any(provider) You can also use an array with the IN operator, but you must specify the column name: color: color IN (\"red\", \"blue\", \"green\")","title":"any"},{"location":"column-rules/#unique","text":"Tests whether a column is unique. items: unique() # You can also test that a set of columns are unique. color: unique(size, weight) # remember that color is implicit Note unique does not work well on large datasets. It stores a hash digest of the arguments to test for uniqueness.","title":"unique"},{"location":"column-rules/#identical","text":"Tests whether all values of a column are identical. dataset_id: identical()","title":"identical"},{"location":"column-rules/#is_subset_list","text":"is_subset_list(group_set, column_delimiter) group_set - A comma-delimited set of values. column_delimiter - The delimiter for the specified column you are testing. Tests whether a delimited list (nested data) is a subset of the specified delimited list. For example: letters: is_subset_list(\"A,B,C\", \",\") # If letters='A,B' --> TRUE letters: is_subset_list(\"A,C\", \",\") # If letters='A'B' --> FALSE","title":"is_subset_list"},{"location":"column-rules/#numbers","text":"","title":"Numbers"},{"location":"column-rules/#range","text":"range(lower, upper) Tests whether a value falls between lower and upper inclusive. rating: range(0,10)","title":"range"},{"location":"column-rules/#is_positive","text":"Tests whether a value is positive.","title":"is_positive"},{"location":"column-rules/#is_negative","text":"Tests whether a value is negative.","title":"is_negative"},{"location":"column-rules/#strings","text":"","title":"Strings"},{"location":"column-rules/#contains","text":"contains(substring) Tests for the presence of a substring in a value.","title":"contains"},{"location":"column-rules/#regex","text":"regex(expression) Tests whether a value matches a regular expression. You can also use =~ or !~ regex comparators. (colname =~ \"L[0-9]+\")","title":"regex"},{"location":"column-rules/#uppercase","text":"Tests whether a value is all uppercase.","title":"uppercase"},{"location":"column-rules/#lowercase","text":"Tests whether a value is all lowercase.","title":"lowercase"},{"location":"column-rules/#length","text":"length(min_len, max_len) Tests for string length in a given column. # Test for exact length match column: length(10) # Test for minimum length column: length(10, \"*\") # Test for range of lengths column: length(10, 20)","title":"length"},{"location":"column-rules/#is_url","text":"Tests whether a string is a valid URL","title":"is_url"},{"location":"column-rules/#types","text":"","title":"Types"},{"location":"column-rules/#is_numeric","text":"Checks if the value numeric.","title":"is_numeric"},{"location":"column-rules/#is_int","text":"Checks if the value an integer.","title":"is_int"},{"location":"column-rules/#is_bool","text":"Tests that column contains true , TRUE , false , or FALSE","title":"is_bool"},{"location":"column-rules/#is_string","text":"Checks if the value is a string. This is done by checking that it does not look like an integer, bool, or numeric.","title":"is_string"},{"location":"column-rules/#dates","text":"","title":"Dates"},{"location":"column-rules/#is_date","text":"Checks whether a value is date-like using strict criteria. is_date will fail on ambiguous date strings. For example, 02/03/2020 is interpretted differently in Europe vs. the US but 2020-02-03 is not.","title":"is_date"},{"location":"column-rules/#is_date_relaxed","text":"Checks whether a value is date-like with potential ambiguity. 02/03/2020 would pass.","title":"is_date_relaxed"},{"location":"column-rules/#is_date_format","text":"Check whether a column matches a specified date format. Formats can be specified as any date like this: September 17, 2012, 10:10:09 oct. 7, 70 8/8/1965 12:00:00 AM 2006-01-02T15:04:05+0000 2014-04-26 date_of_birth: is_date_format(\"June 10, 1987\") See araddon/dateparse for more examples. Important! You need to escape date values containing dashes using brackets ( [] ) or a double backslash ( \\\\ ). For example 2020-02-10 is escaped like this: collection_date: is_date_format(\"[2020-02-10]\") collection_date: is_date_format(\"2020\\\\-02\\\\-10\")","title":"is_date_format"},{"location":"column-rules/#files","text":"","title":"Files"},{"location":"column-rules/#file_exists","text":"Checks whether a file exists","title":"file_exists"},{"location":"column-rules/#file_min_size","text":"Checks whether a file is a minimum size photo: file_min_size(\"1MB\") fsize is a size string such as 100 mb , 1G , or 500 .","title":"file_min_size"},{"location":"column-rules/#mimetype","text":"Validates the mimetype for a given file. See gabriel-vasile/mimetype for available mimetypes. photo: mimetype(\"image/jpeg\")","title":"mimetype"},{"location":"column-rules/#missing_data","text":"","title":"Missing Data"},{"location":"column-rules/#is_na","text":"Checks whether a value is NA . Use !is_na() to restrict the presence of EMPTY values. name: !is_na() # tests that no NA values exist","title":"is_na"},{"location":"column-rules/#is_empty","text":"Checks whether a value is EMPTY . Use !is_empty() to restrict the presence of EMPTY values. name: !is_empty() # tests that no EMPTY values exist","title":"is_empty"},{"location":"column-rules/#is_missing","text":"Returns true if is_na() or is_empty() is true. name: !is_empty() # tests that no NA or EMPTY values exist","title":"is_missing"},{"location":"column-rules/#providers","text":"Providers allow you to specify arguments in test expressions from an external data source. For example, if you want to restrict","title":"Providers"},{"location":"column-rules/#schema_yaml","text":"You can append YAML data to the end of a .still datafile. See Schmema YAML Data for more details.","title":"Schema YAML"},{"location":"column-rules/#yaml_file","text":"","title":"YAML File"},{"location":"functions/","text":"Functions \u00b6 Functions operate at the row level. if_else \u00b6 if_else(condition, expr_if_true, expr_if_false) // A ternary operator is also supported. (condition ? expr_if_true : expr_if_false) condition - An expression that evaluates to TRUE or FALSE . expr_if_true - Value to return if condition=-TRUE expr_if_false - Value to return if condition==FALSE The if_else function evaluates an expression and returns expr_if_true or expr_if_false depending on the evaluation of condition . flavor: if_else(flavor == \"Chocolate\", sugar > 50, sugar < 50) max \u00b6 Returns the max of arguments passed orders: max(1,2,3) == 3 # Returns 3 == 3; true items: max(col1, col2, col3) # Returns the max value for the given row of col1-3. inventory: max(col1) # This does not return the max for an entire column; col1 is a scaler value. min \u00b6 Returns the minimum of arguments passed to_lower \u00b6 Converts a string to lowercase. to_upper \u00b6 Converts a string to uppercase. replace \u00b6 replace(value, find, replace) count \u00b6 count(column) Returns the number of times the passed value(s) have been observed. color: count(color) <= 20 # Fails if a value is observed more than 20x times. configuration: count(color, size) <= 10 # Fails if the combination of values is observed more than 10 times. Note count does not work well on large datasets. It stores a hash digest of the arguments to test for uniqueness. null coalescence \u00b6 ?? can be used to set a default value. (colname ?? 1) == 1 # returns TRUE if colname==NA/nil Two-Pass Functions \u00b6 Two-pass functions allow for more advanced expressions to be evaluated, but they require a first-pass through the file to collect information. group_count \u00b6 group_count(group_column, count_column, eq_value) group_count will group data by the group_column , and count the number of occurences of eq_value in the count_column . example family_id: is_int() person: group_count(person, is_head_of_household, true) == 1 is_head_of_household: is_bool() In the example above, we are checking to see that only one person in a family is set to true for the column is_head_of_household . If you have missing data in your grouping column you may need use an if_else statement to conditionally validate a row as true: family_id: is_int() person: if_else(is_missing(), true, group_count(person, is_head_of_household, true) == 1) is_head_of_household: is_bool()","title":"Functions"},{"location":"functions/#functions","text":"Functions operate at the row level.","title":"Functions"},{"location":"functions/#if_else","text":"if_else(condition, expr_if_true, expr_if_false) // A ternary operator is also supported. (condition ? expr_if_true : expr_if_false) condition - An expression that evaluates to TRUE or FALSE . expr_if_true - Value to return if condition=-TRUE expr_if_false - Value to return if condition==FALSE The if_else function evaluates an expression and returns expr_if_true or expr_if_false depending on the evaluation of condition . flavor: if_else(flavor == \"Chocolate\", sugar > 50, sugar < 50)","title":"if_else"},{"location":"functions/#max","text":"Returns the max of arguments passed orders: max(1,2,3) == 3 # Returns 3 == 3; true items: max(col1, col2, col3) # Returns the max value for the given row of col1-3. inventory: max(col1) # This does not return the max for an entire column; col1 is a scaler value.","title":"max"},{"location":"functions/#min","text":"Returns the minimum of arguments passed","title":"min"},{"location":"functions/#to_lower","text":"Converts a string to lowercase.","title":"to_lower"},{"location":"functions/#to_upper","text":"Converts a string to uppercase.","title":"to_upper"},{"location":"functions/#replace","text":"replace(value, find, replace)","title":"replace"},{"location":"functions/#count","text":"count(column) Returns the number of times the passed value(s) have been observed. color: count(color) <= 20 # Fails if a value is observed more than 20x times. configuration: count(color, size) <= 10 # Fails if the combination of values is observed more than 10 times. Note count does not work well on large datasets. It stores a hash digest of the arguments to test for uniqueness.","title":"count"},{"location":"functions/#null_coalescence","text":"?? can be used to set a default value. (colname ?? 1) == 1 # returns TRUE if colname==NA/nil","title":"null coalescence"},{"location":"functions/#two-pass_functions","text":"Two-pass functions allow for more advanced expressions to be evaluated, but they require a first-pass through the file to collect information.","title":"Two-Pass Functions"},{"location":"functions/#group_count","text":"group_count(group_column, count_column, eq_value) group_count will group data by the group_column , and count the number of occurences of eq_value in the count_column . example family_id: is_int() person: group_count(person, is_head_of_household, true) == 1 is_head_of_household: is_bool() In the example above, we are checking to see that only one person in a family is set to true for the column is_head_of_household . If you have missing data in your grouping column you may need use an if_else statement to conditionally validate a row as true: family_id: is_int() person: if_else(is_missing(), true, group_count(person, is_head_of_household, true) == 1) is_head_of_household: is_bool()","title":"group_count"},{"location":"getting-started/","text":"Still \u00b6 still is a program for validating tabular data from CSV, TSV, and Excel. Quick Start \u00b6 Generate a schema. Directives start with @ and refer to global options. These are followed by column names and test expressions. cars.schema @separater TAB mpg: is_numeric() cyl: range(2,8) hp: is_positive() && range(10, 500) vs: is(0) || is(1) am: any(0, 1) Then run the command line tool: still validate cars.schema cars.tsv","title":"Getting Started"},{"location":"getting-started/#still","text":"still is a program for validating tabular data from CSV, TSV, and Excel.","title":"Still"},{"location":"getting-started/#quick_start","text":"Generate a schema. Directives start with @ and refer to global options. These are followed by column names and test expressions. cars.schema @separater TAB mpg: is_numeric() cyl: range(2,8) hp: is_positive() && range(10, 500) vs: is(0) || is(1) am: any(0, 1) Then run the command line tool: still validate cars.schema cars.tsv","title":"Quick Start"},{"location":"schema/","text":"Schema \u00b6 Schemas have the following structure: directives - specify global rules and settings. column rules - Define a set of expressions on which to evaluate each column. data optional - a yaml-formatted dataset can be appended to the end of a schema to define value sets or other data used in validation. Directives \u00b6 Directives are assigned using a @ prefix and apply global settings. @na_values \u00b6 Use @na_values to specify values to treat as NA . See Missing Data for more details. Default @na_values NA @empty_values \u00b6 Use @empty_values to specify values to treat as EMPTY . Use \"\" for empty cells. See Missing Data for more details. Default @empty_values \"\" NULL @ordered \u00b6 Require that the columns appear in the same order as specified in the schema. @ordered @fixed \u00b6 Require that column names match the schema in the same order. @fixed @separater \u00b6 Sets the separater/delimiter for a data file. Do not quote the delimiter. Use TAB or \\t for tab-delimited data. @separater: TAB # comma-delimited @separater: , @sep also works. Column Rules \u00b6 Column Rules consist of a column name and expressions to test for each column. For example, the following tests that the color column must be equal to red , blue or green . color: any(\"red\", \"blue\", \"green\") Data Providers \u00b6 Certain rules are easier to specify if you need to compare a column against a larger set of data. YAML Data \u00b6 Adding a dashline ( --- ) signals the beginning of the data section of the schema. Any content below the dashline is parsed as YAML and can be accessed in expressions using its key. For example: color_values: - red - blue - green flavor_values: - chocolate - vanilla - strawberry Column rules might be specified like this: color: any(color_values) flavor: any(flavor_values) Functions supporting data providers \u00b6 any Missing Data \u00b6 There are two types of missing data that still manages for additional flexibility. However, you can choose to treat all missing data as NA if desired. NA values represent \u201cknown\u201d missing data. These are similar to NA values in R. EMPTY can be considered \u201cunknown\u201d missing data To clarify further, consider a dataset on cars. The column mpg for all-electric vehicles would be labeled NA (\u201cnot applicable\u201d) as it does not apply. Another scenerio might be that you know the name , make , and mpg of a new vehicle but not the color . This flexibility would allow you to throw an error with an NA value for color, but not for an EMPTY value. Comments \u00b6 You can add comments to your schema file using // or /* block */ . For example: // This is a comment color: any(\"blue\", \"red\", \"green\") // expression for the color column /* Using a block comment is fun */","title":"Schema"},{"location":"schema/#schema","text":"Schemas have the following structure: directives - specify global rules and settings. column rules - Define a set of expressions on which to evaluate each column. data optional - a yaml-formatted dataset can be appended to the end of a schema to define value sets or other data used in validation.","title":"Schema"},{"location":"schema/#directives","text":"Directives are assigned using a @ prefix and apply global settings.","title":"Directives"},{"location":"schema/#na_values","text":"Use @na_values to specify values to treat as NA . See Missing Data for more details. Default @na_values NA","title":"@na_values"},{"location":"schema/#empty_values","text":"Use @empty_values to specify values to treat as EMPTY . Use \"\" for empty cells. See Missing Data for more details. Default @empty_values \"\" NULL","title":"@empty_values"},{"location":"schema/#ordered","text":"Require that the columns appear in the same order as specified in the schema. @ordered","title":"@ordered"},{"location":"schema/#fixed","text":"Require that column names match the schema in the same order. @fixed","title":"@fixed"},{"location":"schema/#separater","text":"Sets the separater/delimiter for a data file. Do not quote the delimiter. Use TAB or \\t for tab-delimited data. @separater: TAB # comma-delimited @separater: , @sep also works.","title":"@separater"},{"location":"schema/#column_rules","text":"Column Rules consist of a column name and expressions to test for each column. For example, the following tests that the color column must be equal to red , blue or green . color: any(\"red\", \"blue\", \"green\")","title":"Column Rules"},{"location":"schema/#data_providers","text":"Certain rules are easier to specify if you need to compare a column against a larger set of data.","title":"Data Providers"},{"location":"schema/#yaml_data","text":"Adding a dashline ( --- ) signals the beginning of the data section of the schema. Any content below the dashline is parsed as YAML and can be accessed in expressions using its key. For example: color_values: - red - blue - green flavor_values: - chocolate - vanilla - strawberry Column rules might be specified like this: color: any(color_values) flavor: any(flavor_values)","title":"YAML Data"},{"location":"schema/#functions_supporting_data_providers","text":"any","title":"Functions supporting data providers"},{"location":"schema/#missing_data","text":"There are two types of missing data that still manages for additional flexibility. However, you can choose to treat all missing data as NA if desired. NA values represent \u201cknown\u201d missing data. These are similar to NA values in R. EMPTY can be considered \u201cunknown\u201d missing data To clarify further, consider a dataset on cars. The column mpg for all-electric vehicles would be labeled NA (\u201cnot applicable\u201d) as it does not apply. Another scenerio might be that you know the name , make , and mpg of a new vehicle but not the color . This flexibility would allow you to throw an error with an NA value for color, but not for an EMPTY value.","title":"Missing Data"},{"location":"schema/#comments","text":"You can add comments to your schema file using // or /* block */ . For example: // This is a comment color: any(\"blue\", \"red\", \"green\") // expression for the color column /* Using a block comment is fun */","title":"Comments"},{"location":"validate/","text":"Validate \u00b6 The validate command is used to run validation with a .still schema. still validate <input> <schema> Options \u00b6 --order \u00b6 The column ordering in the output report can be set using the --order option. --order data - Columns ordered as they appear in data. --order schema - Columns ordered as they appear in schema.","title":"Validate"},{"location":"validate/#validate","text":"The validate command is used to run validation with a .still schema. still validate <input> <schema>","title":"Validate"},{"location":"validate/#options","text":"","title":"Options"},{"location":"validate/#--order","text":"The column ordering in the output report can be set using the --order option. --order data - Columns ordered as they appear in data. --order schema - Columns ordered as they appear in schema.","title":"--order"}]}